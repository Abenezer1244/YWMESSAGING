import axios from 'axios';
/**
 * Format agent responses into a GitHub PR comment
 */
export function formatAgentFindingsForGitHub(responses) {
    let comment = `# ğŸ¤– Automated Agent Analysis\n\n`;
    // Add timestamp
    comment += `*Analysis completed at ${new Date().toISOString()}*\n\n`;
    // Group by severity for quick scan
    const bySeverity = {
        critical: responses.filter((r) => r.severity === 'critical'),
        high: responses.filter((r) => r.severity === 'high'),
        medium: responses.filter((r) => r.severity === 'medium'),
        low: responses.filter((r) => r.severity === 'low'),
        info: responses.filter((r) => r.severity === 'info'),
    };
    // Add severity summary
    const severityEmojis = {
        critical: 'ğŸ”´',
        high: 'ğŸŸ ',
        medium: 'ğŸŸ¡',
        low: 'ğŸŸ¢',
        info: 'ğŸ”µ',
    };
    comment += `## Summary\n\n`;
    Object.entries(bySeverity).forEach(([severity, items]) => {
        if (items.length > 0) {
            comment += `${severityEmojis[severity]} **${severity.toUpperCase()}**: ${items.length} finding${items.length !== 1 ? 's' : ''}\n`;
        }
    });
    comment += '\n---\n\n';
    // Add critical findings first
    const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
    for (const severity of severityOrder) {
        const items = bySeverity[severity];
        if (items.length === 0)
            continue;
        comment += `## ${severity.charAt(0).toUpperCase() + severity.slice(1)} Issues\n\n`;
        items.forEach((response) => {
            const agentIcon = getAgentIcon(response.agentType);
            comment += `### ${agentIcon} ${getAgentName(response.agentType)}\n\n`;
            comment += `${response.summary}\n\n`;
            if (response.findings.length > 0) {
                comment += `**Findings:**\n`;
                response.findings.forEach((finding) => {
                    comment += `- ${finding}\n`;
                });
                comment += '\n';
            }
            if (response.recommendations.length > 0) {
                comment += `**Recommendations:**\n`;
                response.recommendations.forEach((rec) => {
                    comment += `- ${rec}\n`;
                });
                comment += '\n';
            }
            if (response.details) {
                comment += `<details>\n<summary>Details</summary>\n\n`;
                comment += `${response.details}\n\n`;
                comment += `</details>\n\n`;
            }
            comment += '---\n\n';
        });
    }
    // Add footer
    comment += `*Generated by [Automated Agent Analysis](https://github.com)*\n`;
    return comment;
}
/**
 * Post agent findings to a GitHub PR as a comment
 */
export async function postPRComment(context, responses) {
    const { repoOwner, repoName, prNumber } = context;
    const githubToken = process.env.GITHUB_TOKEN;
    if (!githubToken) {
        console.error('âŒ GITHUB_TOKEN environment variable not configured');
        return false;
    }
    try {
        const comment = formatAgentFindingsForGitHub(responses);
        console.log(`\nğŸ“ Posting agent findings to PR #${prNumber}...`);
        // Call GitHub API to create comment
        const response = await axios.post(`https://api.github.com/repos/${repoOwner}/${repoName}/issues/${prNumber}/comments`, { body: comment }, {
            headers: {
                Authorization: `token ${githubToken}`,
                'Content-Type': 'application/json',
                Accept: 'application/vnd.github.v3+json',
            },
        });
        const commentUrl = response.data.html_url;
        console.log(`âœ… PR comment posted successfully`);
        console.log(`   URL: ${commentUrl}`);
        return true;
    }
    catch (error) {
        console.error(`âŒ Failed to post PR comment:`, error.message);
        if (error.response?.data) {
            console.error('   GitHub API error:', error.response.data);
        }
        return false;
    }
}
/**
 * Update existing agent findings comment (for re-runs)
 */
export async function updatePRComment(context, commentId, responses) {
    const { repoOwner, repoName } = context;
    const githubToken = process.env.GITHUB_TOKEN;
    if (!githubToken) {
        console.error('âŒ GITHUB_TOKEN environment variable not configured');
        return false;
    }
    try {
        const comment = formatAgentFindingsForGitHub(responses);
        console.log(`\nğŸ“ Updating PR comment #${commentId}...`);
        await axios.patch(`https://api.github.com/repos/${repoOwner}/${repoName}/issues/comments/${commentId}`, { body: comment }, {
            headers: {
                Authorization: `token ${githubToken}`,
                'Content-Type': 'application/json',
                Accept: 'application/vnd.github.v3+json',
            },
        });
        console.log(`âœ… PR comment updated successfully`);
        return true;
    }
    catch (error) {
        console.error(`âŒ Failed to update PR comment:`, error.message);
        return false;
    }
}
/**
 * Find existing agent findings comment on a PR
 */
export async function findAgentComment(context) {
    const { repoOwner, repoName, prNumber } = context;
    const githubToken = process.env.GITHUB_TOKEN;
    if (!githubToken) {
        return null;
    }
    try {
        const response = await axios.get(`https://api.github.com/repos/${repoOwner}/${repoName}/issues/${prNumber}/comments`, {
            headers: {
                Authorization: `token ${githubToken}`,
                Accept: 'application/vnd.github.v3+json',
            },
        });
        // Look for existing agent findings comment
        const agentComment = response.data.find((comment) => comment.user.login === 'github-actions' ||
            comment.body.includes('Automated Agent Analysis'));
        return agentComment?.id || null;
    }
    catch (error) {
        console.warn('âš ï¸ Failed to fetch PR comments:', error.message);
        return null;
    }
}
/**
 * Post or update agent findings on PR (idempotent)
 */
export async function postOrUpdatePRFindings(context, responses) {
    // Try to find existing comment
    const existingCommentId = await findAgentComment(context);
    if (existingCommentId) {
        // Update existing comment
        return updatePRComment(context, existingCommentId, responses);
    }
    else {
        // Create new comment
        return postPRComment(context, responses);
    }
}
/**
 * Helper: Get agent display icon
 */
function getAgentIcon(agentType) {
    const icons = {
        'backend-engineer': 'ğŸ”§',
        'senior-frontend': 'ğŸ¨',
        'security-analyst': 'ğŸ”’',
        'design-review': 'âœ¨',
        'qa-testing': 'âœ…',
        'system-architecture': 'ğŸ—ï¸',
        devops: 'ğŸš€',
        'product-manager': 'ğŸ“Š',
        'ui-ux': 'ğŸ–¼ï¸',
    };
    return icons[agentType] || 'ğŸ¤–';
}
/**
 * Helper: Get agent display name
 */
function getAgentName(agentType) {
    const names = {
        'backend-engineer': 'Backend Engineer',
        'senior-frontend': 'Senior Frontend Engineer',
        'security-analyst': 'Security Analyst',
        'design-review': 'Design Review',
        'qa-testing': 'QA Testing',
        'system-architecture': 'System Architecture',
        devops: 'DevOps',
        'product-manager': 'Product Manager',
        'ui-ux': 'UI/UX Design',
    };
    return names[agentType] || agentType;
}
//# sourceMappingURL=github-results.service.js.map