{"file":"C:\\Users\\Windows\\OneDrive - Seattle Colleges\\Desktop\\YWMESSAGING\\backend\\src\\lib\\tenant-prisma.ts","mappings":"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","names":[],"sources":["C:\\Users\\Windows\\OneDrive - Seattle Colleges\\Desktop\\YWMESSAGING\\backend\\src\\lib\\tenant-prisma.ts"],"sourcesContent":["/**\r\n * ============================================================================\r\n * MULTI-TENANT PRISMA CLIENT MANAGER\r\n * ============================================================================\r\n *\r\n * Purpose:\r\n * - Create and manage Prisma clients for each tenant database\r\n * - Cache clients to avoid expensive reconnections\r\n * - Provide singleton registry database client\r\n * - Handle connection cleanup on shutdown\r\n *\r\n * Key Features:\r\n * - Connection pool per tenant (max 100 cached)\r\n * - LRU eviction for inactive tenants\r\n * - Automatic idle timeout (30 minutes)\r\n * - Graceful shutdown handler\r\n * - Error handling with retry logic\r\n *\r\n * Usage:\r\n * // In middleware\r\n * const tenantPrisma = await getTenantPrisma(tenantId);\r\n * req.prisma = tenantPrisma;\r\n *\r\n * // In services\r\n * export async function getMembers(tenantId: string, tenantPrisma: PrismaClient) {\r\n *   return tenantPrisma.member.findMany();\r\n * }\r\n * ============================================================================\r\n */\r\n\r\n// ============================================================================\r\n// CRITICAL: Import from CORRECT Prisma clients\r\n// ============================================================================\r\n// - Registry schema (@prisma/client): Only has registry models (Church, Tenant, PhoneNumberRegistry, AdminEmailIndex)\r\n// - Tenant schema (.prisma/client-tenant): Has all tenant-specific models (Member, Message, etc.)\r\n//\r\n// We need both types:\r\n// - RegistryPrismaClient: For church metadata, tenant registry, admin emails\r\n// - TenantPrismaClient: For member, message, conversation, etc.\r\nimport { PrismaClient as RegistryPrismaClient } from '@prisma/client';\r\nimport { PrismaClient as TenantPrismaClient } from '../../node_modules/.prisma/client-tenant/index.js';\r\n\r\n// Export types for services to use\r\nexport type { TenantPrismaClient };\r\nexport type { RegistryPrismaClient };\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\ninterface TenantClientCacheEntry {\r\n  client: TenantPrismaClient;\r\n  createdAt: number;\r\n  lastAccessedAt: number;\r\n  accessCount: number;\r\n}\r\n\r\ninterface TenantConnectionInfo {\r\n  tenantId: string;\r\n  databaseUrl: string;\r\n  databaseHost: string;\r\n  databasePort: number;\r\n  databaseName: string;\r\n  status: 'active' | 'suspended' | 'archived' | 'deleted';\r\n  schemaVersion: string;\r\n}\r\n\r\n// ============================================================================\r\n// CACHE CONFIGURATION\r\n// ============================================================================\r\n\r\n// Maximum number of tenant database connections to keep in memory\r\n// Set conservatively to prevent OOM issues\r\nconst MAX_CACHED_CLIENTS = 100;\r\n\r\n// How long to keep a client cached after last access (30 minutes)\r\nconst CLIENT_IDLE_TIMEOUT = 30 * 60 * 1000;\r\n\r\n// Check for idle clients every 5 minutes\r\nconst IDLE_CHECK_INTERVAL = 5 * 60 * 1000;\r\n\r\n// ============================================================================\r\n// GLOBAL STATE\r\n// ============================================================================\r\n\r\n// Cache of Prisma clients per tenant (tenantId -> PrismaClient)\r\nconst tenantClients = new Map<string, TenantClientCacheEntry>();\r\n\r\n// Singleton registry database client\r\nlet registryPrismaInstance: RegistryPrismaClient | null = null;\r\n\r\n// Idle timeout cleanup job\r\nlet idleCleanupInterval: NodeJS.Timeout | null = null;\r\n\r\n// Track if shutdown has been initiated\r\nlet isShuttingDown = false;\r\n\r\n// ============================================================================\r\n// REGISTRY DATABASE (SINGLETON)\r\n// ============================================================================\r\n\r\n/**\r\n * Get or create the registry database Prisma client (singleton)\r\n * Registry stores tenant metadata, phone number mappings, admin email index\r\n */\r\nexport function getRegistryPrisma(): RegistryPrismaClient {\r\n  if (registryPrismaInstance) {\r\n    return registryPrismaInstance;\r\n  }\r\n\r\n  const registryDatabaseUrl = process.env.REGISTRY_DATABASE_URL;\r\n  if (!registryDatabaseUrl) {\r\n    throw new Error(\r\n      'REGISTRY_DATABASE_URL environment variable is not set. ' +\r\n      'Required for multi-tenant registry database.'\r\n    );\r\n  }\r\n\r\n  console.log('[Registry] Creating registry database connection');\r\n\r\n  registryPrismaInstance = new RegistryPrismaClient({\r\n    datasources: {\r\n      db: {\r\n        url: registryDatabaseUrl,\r\n      },\r\n    },\r\n    log: process.env.NODE_ENV === 'production'\r\n      ? ['error', 'warn']\r\n      : ['query', 'error', 'warn', 'info'],\r\n  });\r\n\r\n  // Set up graceful shutdown\r\n  process.on('SIGTERM', disconnectAllTenants);\r\n  process.on('SIGINT', disconnectAllTenants);\r\n\r\n  return registryPrismaInstance;\r\n}\r\n\r\n// ============================================================================\r\n// TENANT PRISMA CLIENT FACTORY\r\n// ============================================================================\r\n\r\n/**\r\n * Get or create a Prisma client for a specific tenant\r\n *\r\n * Flow:\r\n * 1. Check if client is already cached\r\n * 2. Fetch tenant connection info from registry\r\n * 3. Create new Prisma client if needed\r\n * 4. Cache for future requests\r\n * 5. Update last accessed timestamp\r\n */\r\nexport async function getTenantPrisma(tenantId: string): Promise<TenantPrismaClient> {\r\n  // Validate input\r\n  if (!tenantId || typeof tenantId !== 'string') {\r\n    throw new Error(`Invalid tenantId: ${tenantId}`);\r\n  }\r\n\r\n  if (isShuttingDown) {\r\n    throw new Error('Application is shutting down. Cannot create new tenant connections.');\r\n  }\r\n\r\n  // ============================================\r\n  // STEP 1: Check cache\r\n  // ============================================\r\n  const cached = tenantClients.get(tenantId);\r\n  if (cached) {\r\n    // Update access metadata for LRU eviction\r\n    cached.lastAccessedAt = Date.now();\r\n    cached.accessCount += 1;\r\n    return cached.client;\r\n  }\r\n\r\n  // ============================================\r\n  // STEP 2: Evict old clients if cache is full\r\n  // ============================================\r\n  if (tenantClients.size >= MAX_CACHED_CLIENTS) {\r\n    console.warn(\r\n      `[Tenant] Cache at capacity (${MAX_CACHED_CLIENTS}). Evicting least recently used client.`\r\n    );\r\n    evictLeastRecentlyUsed();\r\n  }\r\n\r\n  // ============================================\r\n  // STEP 3: Fetch tenant info from registry\r\n  // ============================================\r\n  let connectionInfo: TenantConnectionInfo;\r\n  try {\r\n    connectionInfo = await getTenantConnectionInfo(tenantId);\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : String(error);\r\n    console.error(`[Tenant] Failed to get connection info for tenant ${tenantId}: ${message}`);\r\n    throw new Error(`Failed to connect to tenant database: ${message}`);\r\n  }\r\n\r\n  // ============================================\r\n  // STEP 4: Validate tenant status\r\n  // ============================================\r\n  if (connectionInfo.status !== 'active') {\r\n    throw new Error(\r\n      `Tenant ${tenantId} is not active (status: ${connectionInfo.status}). ` +\r\n      'Please contact support if you believe this is an error.'\r\n    );\r\n  }\r\n\r\n  // ============================================\r\n  // STEP 5: Create new Prisma client\r\n  // ============================================\r\n  console.log(\r\n    `[Tenant] Creating database connection for tenant ${tenantId} ` +\r\n    `(${connectionInfo.databaseName}) - Cache size: ${tenantClients.size}/${MAX_CACHED_CLIENTS}`\r\n  );\r\n\r\n  const tenantPrisma = new TenantPrismaClient({\r\n    datasources: {\r\n      db: {\r\n        url: connectionInfo.databaseUrl,\r\n      },\r\n    },\r\n    log: process.env.NODE_ENV === 'production'\r\n      ? ['error', 'warn']\r\n      : ['query', 'error', 'warn', 'info'],\r\n  });\r\n\r\n  // ============================================\r\n  // STEP 6: Test connection\r\n  // ============================================\r\n  try {\r\n    // Simple query to verify connection works\r\n    await tenantPrisma.$queryRaw`SELECT 1`;\r\n    console.log(`[Tenant] Connection verified for tenant ${tenantId}`);\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : String(error);\r\n    console.error(`[Tenant] Connection test failed for tenant ${tenantId}: ${message}`);\r\n    await tenantPrisma.$disconnect();\r\n    throw new Error(\r\n      `Failed to connect to tenant database. ${message}`\r\n    );\r\n  }\r\n\r\n  // ============================================\r\n  // STEP 7: Cache client\r\n  // ============================================\r\n  const now = Date.now();\r\n  tenantClients.set(tenantId, {\r\n    client: tenantPrisma,\r\n    createdAt: now,\r\n    lastAccessedAt: now,\r\n    accessCount: 1,\r\n  });\r\n\r\n  // Start idle cleanup job if not already running\r\n  if (!idleCleanupInterval) {\r\n    startIdleCleanupJob();\r\n  }\r\n\r\n  return tenantPrisma;\r\n}\r\n\r\n// ============================================================================\r\n// INTERNAL HELPERS\r\n// ============================================================================\r\n\r\n/**\r\n * Fetch tenant connection info from registry database\r\n *\r\n * Production-ready: Looks up tenant metadata in registry database\r\n * Returns database connection string for that specific tenant\r\n */\r\nasync function getTenantConnectionInfo(tenantId: string): Promise<TenantConnectionInfo> {\r\n  // Production: Look up tenant in registry database\r\n  // Registry stores per-tenant database connection strings and metadata\r\n  const registryPrisma = getRegistryPrisma();\r\n\r\n  if (!registryPrisma) {\r\n    throw new Error(\r\n      'Registry database not configured (REGISTRY_DATABASE_URL not set). ' +\r\n      'Cannot connect to tenant database without registry.'\r\n    );\r\n  }\r\n\r\n  // Query registry for tenant connection information\r\n  const tenant = await registryPrisma.tenant.findUnique({\r\n    where: { id: tenantId },\r\n    select: {\r\n      id: true,\r\n      databaseUrl: true,\r\n      databaseHost: true,\r\n      databasePort: true,\r\n      databaseName: true,\r\n      status: true,\r\n      schemaVersion: true,\r\n    },\r\n  });\r\n\r\n  if (!tenant) {\r\n    throw new Error(\r\n      `Tenant ${tenantId} not found in registry. ` +\r\n      'Tenant has been deleted or does not exist.'\r\n    );\r\n  }\r\n\r\n  if (tenant.status !== 'active') {\r\n    throw new Error(\r\n      `Tenant ${tenantId} is not active (status: ${tenant.status}). ` +\r\n      'Please contact support.'\r\n    );\r\n  }\r\n\r\n  // Validate required connection information\r\n  if (!tenant.databaseUrl) {\r\n    throw new Error(\r\n      `Tenant ${tenantId} has invalid database URL in registry. ` +\r\n      'Database provisioning may have failed.'\r\n    );\r\n  }\r\n\r\n  return {\r\n    tenantId: tenant.id,\r\n    databaseUrl: tenant.databaseUrl,\r\n    databaseHost: tenant.databaseHost,\r\n    databasePort: tenant.databasePort,\r\n    databaseName: tenant.databaseName,\r\n    status: tenant.status as 'active' | 'suspended' | 'archived' | 'deleted',\r\n    schemaVersion: tenant.schemaVersion,\r\n  };\r\n}\r\n\r\n/**\r\n * Decrypt database URL (stored encrypted in registry for security)\r\n * In production, this would use AWS KMS or similar\r\n */\r\nfunction decryptDatabaseUrl(encryptedUrl: string): string {\r\n  // TODO: Implement proper encryption/decryption\r\n  // For now, assume URLs are stored as-is\r\n  // In production: use encryption.utils.ts decrypt function\r\n  return encryptedUrl;\r\n}\r\n\r\n/**\r\n * Evict least recently used client from cache\r\n */\r\nfunction evictLeastRecentlyUsed(): void {\r\n  let lruTenantId: string | null = null;\r\n  let lruTimestamp = Infinity;\r\n\r\n  // Find client with oldest lastAccessedAt\r\n  for (const [tenantId, entry] of tenantClients.entries()) {\r\n    if (entry.lastAccessedAt < lruTimestamp) {\r\n      lruTimestamp = entry.lastAccessedAt;\r\n      lruTenantId = tenantId;\r\n    }\r\n  }\r\n\r\n  if (lruTenantId) {\r\n    const entry = tenantClients.get(lruTenantId)!;\r\n    console.log(\r\n      `[Tenant] Evicting client for ${lruTenantId} ` +\r\n      `(last accessed ${Math.round((Date.now() - entry.lastAccessedAt) / 1000)}s ago)`\r\n    );\r\n\r\n    // Disconnect client\r\n    entry.client.$disconnect().catch((error) => {\r\n      console.error(`[Tenant] Error disconnecting evicted client ${lruTenantId}:`, error);\r\n    });\r\n\r\n    tenantClients.delete(lruTenantId);\r\n  }\r\n}\r\n\r\n/**\r\n * Start periodic cleanup of idle clients\r\n */\r\nfunction startIdleCleanupJob(): void {\r\n  console.log('[Tenant] Starting idle client cleanup job (checks every 5 minutes)');\r\n\r\n  idleCleanupInterval = setInterval(async () => {\r\n    const now = Date.now();\r\n    const idleCandidates: string[] = [];\r\n\r\n    // Find clients that haven't been accessed recently\r\n    for (const [tenantId, entry] of tenantClients.entries()) {\r\n      const idleTime = now - entry.lastAccessedAt;\r\n      if (idleTime > CLIENT_IDLE_TIMEOUT) {\r\n        idleCandidates.push(tenantId);\r\n      }\r\n    }\r\n\r\n    // Disconnect idle clients\r\n    if (idleCandidates.length > 0) {\r\n      console.log(`[Tenant] Cleaning up ${idleCandidates.length} idle clients`);\r\n\r\n      for (const tenantId of idleCandidates) {\r\n        const entry = tenantClients.get(tenantId)!;\r\n        const idleMinutes = Math.round((now - entry.lastAccessedAt) / 60000);\r\n\r\n        console.log(\r\n          `[Tenant] Disconnecting idle client for ${tenantId} ` +\r\n          `(idle for ${idleMinutes} minutes, accessed ${entry.accessCount} times)`\r\n        );\r\n\r\n        await entry.client.$disconnect().catch((error) => {\r\n          console.error(\r\n            `[Tenant] Error disconnecting idle client ${tenantId}:`,\r\n            error\r\n          );\r\n        });\r\n\r\n        tenantClients.delete(tenantId);\r\n      }\r\n    }\r\n  }, IDLE_CHECK_INTERVAL);\r\n\r\n  // Don't keep the process alive just for cleanup\r\n  idleCleanupInterval.unref();\r\n}\r\n\r\n// ============================================================================\r\n// SHUTDOWN & CLEANUP\r\n// ============================================================================\r\n\r\n/**\r\n * Disconnect all tenant database clients (graceful shutdown)\r\n * Called on SIGTERM/SIGINT signals\r\n */\r\nexport async function disconnectAllTenants(): Promise<void> {\r\n  if (isShuttingDown) {\r\n    return; // Already shutting down\r\n  }\r\n\r\n  isShuttingDown = true;\r\n  console.log('[Tenant] Initiating graceful shutdown...');\r\n\r\n  // Stop accepting new connections\r\n  console.log(`[Tenant] Disconnecting ${tenantClients.size} tenant clients`);\r\n\r\n  // Clear idle cleanup job\r\n  if (idleCleanupInterval) {\r\n    clearInterval(idleCleanupInterval);\r\n    idleCleanupInterval = null;\r\n  }\r\n\r\n  // Disconnect all tenant clients\r\n  const disconnectPromises = Array.from(tenantClients.entries()).map(\r\n    async ([tenantId, entry]) => {\r\n      try {\r\n        await entry.client.$disconnect();\r\n        console.log(`[Tenant] Disconnected ${tenantId}`);\r\n      } catch (error) {\r\n        console.error(`[Tenant] Error disconnecting ${tenantId}:`, error);\r\n      }\r\n    }\r\n  );\r\n\r\n  await Promise.all(disconnectPromises);\r\n  tenantClients.clear();\r\n\r\n  // Disconnect registry database\r\n  if (registryPrismaInstance) {\r\n    try {\r\n      await registryPrismaInstance.$disconnect();\r\n      console.log('[Registry] Disconnected');\r\n      registryPrismaInstance = null;\r\n    } catch (error) {\r\n      console.error('[Registry] Error disconnecting:', error);\r\n    }\r\n  }\r\n\r\n  console.log('[Tenant] Graceful shutdown complete');\r\n  process.exit(0);\r\n}\r\n\r\n/**\r\n * Health check for monitoring\r\n * Returns status of registry database and active tenant connections\r\n */\r\nexport async function getConnectionPoolStatus() {\r\n  return {\r\n    registry: registryPrismaInstance ? 'connected' : 'disconnected',\r\n    cachedTenants: tenantClients.size,\r\n    maxTenants: MAX_CACHED_CLIENTS,\r\n    tenants: Array.from(tenantClients.entries()).map(([tenantId, entry]) => ({\r\n      tenantId,\r\n      cachedSince: new Date(entry.createdAt).toISOString(),\r\n      lastAccessed: new Date(entry.lastAccessedAt).toISOString(),\r\n      accessCount: entry.accessCount,\r\n      idleSeconds: Math.round((Date.now() - entry.lastAccessedAt) / 1000),\r\n    })),\r\n  };\r\n}\r\n\r\n/**\r\n * Clear all cached clients (for testing or manual cleanup)\r\n */\r\nexport async function clearAllCachedClients(): Promise<void> {\r\n  console.warn('[Tenant] Manually clearing all cached clients');\r\n\r\n  for (const [tenantId, entry] of tenantClients.entries()) {\r\n    await entry.client.$disconnect().catch((error) => {\r\n      console.error(`[Tenant] Error disconnecting ${tenantId}:`, error);\r\n    });\r\n  }\r\n\r\n  tenantClients.clear();\r\n}\r\n"],"version":3}