{"file":"C:\\Users\\Windows\\OneDrive - Seattle Colleges\\Desktop\\YWMESSAGING\\backend\\src\\__tests__\\services\\mfa.service.test.ts","mappings":"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","names":[],"sources":["C:\\Users\\Windows\\OneDrive - Seattle Colleges\\Desktop\\YWMESSAGING\\backend\\src\\__tests__\\services\\mfa.service.test.ts"],"sourcesContent":["import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';\nimport speakeasy from 'speakeasy';\nimport crypto from 'crypto';\n\n/**\n * MFA Service Tests - TOTP and Recovery Code Functionality\n */\n\ndescribe('MFA Service', () => {\n  describe('TOTP Secret Generation (Speakeasy)', () => {\n    it('should generate valid TOTP secret', () => {\n      const secret = speakeasy.generateSecret({\n        name: 'Koinonia SMS (admin@church.com)',\n        issuer: 'Koinonia SMS',\n        length: 32,\n      });\n\n      expect(secret.base32).toBeDefined();\n      expect(secret.otpauth_url).toBeDefined();\n\n      // Verify secret is base32 encoded\n      expect(secret.base32).toMatch(/^[A-Z2-7]+=*$/);\n      expect(secret.base32.length).toBeGreaterThan(30);\n\n      // OTPAuth URL should contain issuer and email\n      expect(secret.otpauth_url).toContain('Koinonia%20SMS');\n      expect(secret.otpauth_url).toContain('admin%40church.com');\n    });\n\n    it('should generate different secrets for different inputs', () => {\n      const secret1 = speakeasy.generateSecret({\n        name: 'Test 1',\n        length: 32,\n      });\n      const secret2 = speakeasy.generateSecret({\n        name: 'Test 2',\n        length: 32,\n      });\n\n      expect(secret1.base32).not.toBe(secret2.base32);\n    });\n\n    it('should support QR code generation from otpauth_url', () => {\n      const secret = speakeasy.generateSecret({\n        name: 'Koinonia SMS (pastor@test.com)',\n        issuer: 'Koinonia SMS',\n        length: 32,\n      });\n\n      // OTPAuth URL is suitable for QR code generation\n      expect(secret.otpauth_url).toBeTruthy();\n      expect(secret.otpauth_url.length).toBeGreaterThan(50);\n      expect(secret.otpauth_url).toMatch(/^otpauth:\\/\\/totp\\//);\n    });\n  });\n\n  describe('TOTP Code Verification', () => {\n    let totpSecret: string;\n\n    beforeAll(() => {\n      const secret = speakeasy.generateSecret({\n        name: 'Koinonia SMS (test@church.com)',\n        issuer: 'Koinonia SMS',\n        length: 32,\n      });\n      if (!secret.base32) throw new Error('Failed to generate secret');\n      totpSecret = secret.base32;\n    });\n\n    it('should generate valid TOTP code from secret', () => {\n      const code = speakeasy.totp({\n        secret: totpSecret,\n        encoding: 'base32',\n      });\n\n      // Code should be 6 digits\n      expect(code).toMatch(/^\\d{6}$/);\n    });\n\n    it('should verify valid TOTP code', () => {\n      const code = speakeasy.totp({\n        secret: totpSecret,\n        encoding: 'base32',\n      });\n\n      const isValid = speakeasy.totp.verify({\n        secret: totpSecret,\n        encoding: 'base32',\n        token: code,\n        window: 2,\n      });\n\n      expect(isValid).toBe(true);\n    });\n\n    it('should reject invalid TOTP code', () => {\n      const isValid = speakeasy.totp.verify({\n        secret: totpSecret,\n        encoding: 'base32',\n        token: '000000',\n        window: 2,\n      });\n\n      expect(isValid).toBeFalsy();\n    });\n\n    it('should accept codes within time window', () => {\n      // Current code\n      const currentCode = speakeasy.totp({\n        secret: totpSecret,\n        encoding: 'base32',\n      });\n\n      // Verify with window of 2 (accepts -1, 0, +1 time windows)\n      const isValid = speakeasy.totp.verify({\n        secret: totpSecret,\n        encoding: 'base32',\n        token: currentCode,\n        window: 2,\n      });\n\n      expect(isValid).toBe(true);\n    });\n\n    it('should reject codes outside time window', () => {\n      // Random invalid code\n      const invalidCode = '123456';\n\n      const isValid = speakeasy.totp.verify({\n        secret: totpSecret,\n        encoding: 'base32',\n        token: invalidCode,\n        window: 2,\n      });\n\n      expect(isValid).toBeFalsy();\n    });\n\n    it('should handle different secret formats', () => {\n      const secret = speakeasy.generateSecret({ length: 32 });\n      if (!secret.base32) throw new Error('Failed to generate secret');\n\n      const code = speakeasy.totp({\n        secret: secret.base32,\n        encoding: 'base32',\n      });\n\n      const isValid = speakeasy.totp.verify({\n        secret: secret.base32,\n        encoding: 'base32',\n        token: code,\n        window: 2,\n      });\n\n      expect(isValid).toBe(true);\n    });\n  });\n\n  describe('Recovery Code Generation (Pure Crypto)', () => {\n    it('should generate recovery code with correct format', () => {\n      // Simulate recovery code generation\n      const RECOVERY_CODE_LENGTH = 8;\n      const code = crypto\n        .randomBytes(Math.ceil(RECOVERY_CODE_LENGTH * 0.75))\n        .toString('base64')\n        .slice(0, RECOVERY_CODE_LENGTH)\n        .toUpperCase();\n      const formatted = `${code.slice(0, 4)}-${code.slice(4)}`;\n\n      expect(formatted).toMatch(/^.{4}-.{4}$/);\n      expect(formatted.length).toBe(9); // 4 + 1 + 4\n    });\n\n    it('should generate different codes each time', () => {\n      const RECOVERY_CODE_LENGTH = 8;\n      const codes: string[] = [];\n\n      for (let i = 0; i < 10; i++) {\n        const code = crypto\n          .randomBytes(Math.ceil(RECOVERY_CODE_LENGTH * 0.75))\n          .toString('base64')\n          .slice(0, RECOVERY_CODE_LENGTH)\n          .toUpperCase();\n        codes.push(code);\n      }\n\n      // All generated codes should be unique\n      const uniqueCodes = new Set(codes);\n      expect(uniqueCodes.size).toBe(10);\n    });\n\n    it('should generate codes with base64 characters (typical format)', () => {\n      const RECOVERY_CODE_LENGTH = 8;\n\n      for (let i = 0; i < 5; i++) {\n        const code = crypto\n          .randomBytes(Math.ceil(RECOVERY_CODE_LENGTH * 0.75))\n          .toString('base64')\n          .slice(0, RECOVERY_CODE_LENGTH)\n          .toUpperCase();\n\n        // Base64 can contain A-Z, 0-9, +, /, =\n        // Recovery codes will have 8 characters\n        expect(code.length).toBe(8);\n        expect(code).toBeTruthy();\n      }\n    });\n\n    it('should have sufficient entropy per code', () => {\n      // Base64 encoding of 6 random bytes = 8 characters with ~48 bits entropy\n      const RECOVERY_CODE_LENGTH = 8;\n      const randomBytes = crypto.randomBytes(Math.ceil(RECOVERY_CODE_LENGTH * 0.75));\n\n      expect(randomBytes.length).toBe(6); // ceil(8 * 0.75) = 6\n      // 6 bytes = 48 bits of entropy - sufficient for recovery codes\n      expect(randomBytes).toHaveLength(6);\n    });\n\n    it('should format multiple codes independently', () => {\n      const codes: string[] = [];\n      const RECOVERY_CODE_LENGTH = 8;\n\n      for (let i = 0; i < 10; i++) {\n        const code = crypto\n          .randomBytes(Math.ceil(RECOVERY_CODE_LENGTH * 0.75))\n          .toString('base64')\n          .slice(0, RECOVERY_CODE_LENGTH)\n          .toUpperCase();\n        codes.push(`${code.slice(0, 4)}-${code.slice(4)}`);\n      }\n\n      // All 10 codes should be formatted correctly\n      expect(codes).toHaveLength(10);\n      codes.forEach(code => {\n        // Should be in format XXXX-XXXX where X can be base64 chars\n        expect(code).toMatch(/^.{4}-.{4}$/);\n        expect(code.length).toBe(9); // 4 + 1 + 4\n      });\n\n      // All should be unique\n      const unique = new Set(codes);\n      expect(unique.size).toBe(10);\n    });\n  });\n\n  describe('Recovery Code Hashing', () => {\n    it('should hash recovery codes with SHA256', async () => {\n      const code = 'ABCD-EFGH';\n      const hash = crypto.createHash('sha256').update(code).digest('hex');\n\n      expect(hash).toMatch(/^[a-f0-9]{64}$/);\n      expect(hash.length).toBe(64);\n    });\n\n    it('should produce consistent hash for same code', () => {\n      const code = 'TEST-CODE';\n      const hash1 = crypto.createHash('sha256').update(code).digest('hex');\n      const hash2 = crypto.createHash('sha256').update(code).digest('hex');\n\n      expect(hash1).toBe(hash2);\n    });\n\n    it('should produce different hashes for different codes', () => {\n      const code1 = 'CODE-1111';\n      const code2 = 'CODE-2222';\n\n      const hash1 = crypto.createHash('sha256').update(code1).digest('hex');\n      const hash2 = crypto.createHash('sha256').update(code2).digest('hex');\n\n      expect(hash1).not.toBe(hash2);\n    });\n  });\n\n  describe('MFA Security Properties', () => {\n    it('should not expose secret in plaintext', () => {\n      const secret = speakeasy.generateSecret({\n        name: 'Test',\n        length: 32,\n      });\n\n      if (!secret.base32) throw new Error('Failed to generate secret');\n\n      // Secret should be base32, not plain ASCII\n      expect(secret.base32).not.toMatch(/[a-z]/); // No lowercase letters\n      expect(secret.base32).toMatch(/^[A-Z2-7]+=*$/); // Only valid base32 chars\n    });\n\n    it('should generate valid otpauth URL for QR code', () => {\n      const secret = speakeasy.generateSecret({\n        name: 'Koinonia SMS (perf@test.com)',\n        issuer: 'Koinonia SMS',\n        length: 32,\n      });\n\n      if (!secret.otpauth_url) throw new Error('Failed to generate otpauth URL');\n\n      // OTPAuth URL is suitable for QR code generation\n      expect(secret.otpauth_url).toMatch(/^otpauth:\\/\\/totp\\//);\n      expect(secret.otpauth_url).toContain('Koinonia%20SMS');\n    });\n\n    it('should handle high-entropy recovery code generation', () => {\n      // Simulate generation of 10 recovery codes\n      const RECOVERY_CODE_LENGTH = 8;\n      const codes: string[] = [];\n\n      for (let i = 0; i < 10; i++) {\n        const code = crypto\n          .randomBytes(Math.ceil(RECOVERY_CODE_LENGTH * 0.75))\n          .toString('base64')\n          .slice(0, RECOVERY_CODE_LENGTH)\n          .toUpperCase();\n        codes.push(code);\n      }\n\n      // Each code has ~48 bits of entropy (6 random bytes)\n      // 10 codes = 480 bits total - very strong\n      expect(codes).toHaveLength(10);\n      codes.forEach((code: string) => {\n        // Code should be 8 characters (possibly including base64 chars like +,/)\n        expect(code.length).toBe(8);\n        expect(code).toBeTruthy();\n      });\n\n      // All should be unique\n      const unique = new Set(codes);\n      expect(unique.size).toBe(10);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle invalid secret gracefully', () => {\n      const isValid = speakeasy.totp.verify({\n        secret: 'INVALID',\n        encoding: 'base32',\n        token: '123456',\n        window: 2,\n      });\n\n      // Should return false, not throw\n      expect(isValid).toBeFalsy();\n    });\n\n    it('should handle empty code', () => {\n      const secret = speakeasy.generateSecret({ length: 32 });\n      if (!secret.base32) throw new Error('Failed to generate secret');\n\n      const isValid = speakeasy.totp.verify({\n        secret: secret.base32,\n        encoding: 'base32',\n        token: '',\n        window: 2,\n      });\n\n      expect(isValid).toBeFalsy();\n    });\n\n    it('should handle non-numeric code', () => {\n      const secret = speakeasy.generateSecret({ length: 32 });\n      if (!secret.base32) throw new Error('Failed to generate secret');\n\n      const isValid = speakeasy.totp.verify({\n        secret: secret.base32,\n        encoding: 'base32',\n        token: 'ABCDEF',\n        window: 2,\n      });\n\n      expect(isValid).toBeFalsy();\n    });\n  });\n});\n"],"version":3}