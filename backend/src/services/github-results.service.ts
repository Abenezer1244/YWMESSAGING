import axios from 'axios';
import { AgentResponse } from './agent-invocation.service.js';

/**
 * GitHub Results Service
 * Posts agent findings back to GitHub PRs as comments
 * Formats responses into GitHub Markdown with severity levels
 */

interface GitHubPRContext {
  repoOwner: string;
  repoName: string;
  prNumber: number;
}

/**
 * Format agent responses into a GitHub PR comment
 */
export function formatAgentFindingsForGitHub(
  responses: AgentResponse[]
): string {
  let comment = `# ü§ñ Automated Agent Analysis\n\n`;

  // Add timestamp
  comment += `*Analysis completed at ${new Date().toISOString()}*\n\n`;

  // Group by severity for quick scan
  const bySeverity = {
    critical: responses.filter((r) => r.severity === 'critical'),
    high: responses.filter((r) => r.severity === 'high'),
    medium: responses.filter((r) => r.severity === 'medium'),
    low: responses.filter((r) => r.severity === 'low'),
    info: responses.filter((r) => r.severity === 'info'),
  };

  // Add severity summary
  const severityEmojis = {
    critical: 'üî¥',
    high: 'üü†',
    medium: 'üü°',
    low: 'üü¢',
    info: 'üîµ',
  };

  comment += `## Summary\n\n`;
  Object.entries(bySeverity).forEach(([severity, items]) => {
    if (items.length > 0) {
      comment += `${severityEmojis[severity as keyof typeof severityEmojis]} **${severity.toUpperCase()}**: ${items.length} finding${items.length !== 1 ? 's' : ''}\n`;
    }
  });
  comment += '\n---\n\n';

  // Add critical findings first
  const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
  for (const severity of severityOrder) {
    const items = bySeverity[severity as keyof typeof bySeverity];
    if (items.length === 0) continue;

    comment += `## ${severity.charAt(0).toUpperCase() + severity.slice(1)} Issues\n\n`;

    items.forEach((response) => {
      const agentIcon = getAgentIcon(response.agentType);
      comment += `### ${agentIcon} ${getAgentName(response.agentType)}\n\n`;
      comment += `${response.summary}\n\n`;

      if (response.findings.length > 0) {
        comment += `**Findings:**\n`;
        response.findings.forEach((finding) => {
          comment += `- ${finding}\n`;
        });
        comment += '\n';
      }

      if (response.recommendations.length > 0) {
        comment += `**Recommendations:**\n`;
        response.recommendations.forEach((rec) => {
          comment += `- ${rec}\n`;
        });
        comment += '\n';
      }

      if (response.details) {
        comment += `<details>\n<summary>Details</summary>\n\n`;
        comment += `${response.details}\n\n`;
        comment += `</details>\n\n`;
      }

      comment += '---\n\n';
    });
  }

  // Add footer
  comment += `*Generated by [Automated Agent Analysis](https://github.com)*\n`;

  return comment;
}

/**
 * Post agent findings to a GitHub PR as a comment
 */
export async function postPRComment(
  context: GitHubPRContext,
  responses: AgentResponse[]
): Promise<boolean> {
  const { repoOwner, repoName, prNumber } = context;
  const githubToken = process.env.GITHUB_TOKEN;

  if (!githubToken) {
    console.error('‚ùå GITHUB_TOKEN environment variable not configured');
    return false;
  }

  try {
    const comment = formatAgentFindingsForGitHub(responses);

    console.log(`\nüìù Posting agent findings to PR #${prNumber}...`);

    // Call GitHub API to create comment
    const response = await axios.post(
      `https://api.github.com/repos/${repoOwner}/${repoName}/issues/${prNumber}/comments`,
      { body: comment },
      {
        headers: {
          Authorization: `token ${githubToken}`,
          'Content-Type': 'application/json',
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    const commentUrl = response.data.html_url;
    console.log(`‚úÖ PR comment posted successfully`);
    console.log(`   URL: ${commentUrl}`);

    return true;
  } catch (error: any) {
    console.error(`‚ùå Failed to post PR comment:`, error.message);
    if (error.response?.data) {
      console.error('   GitHub API error:', error.response.data);
    }
    return false;
  }
}

/**
 * Update existing agent findings comment (for re-runs)
 */
export async function updatePRComment(
  context: GitHubPRContext,
  commentId: number,
  responses: AgentResponse[]
): Promise<boolean> {
  const { repoOwner, repoName } = context;
  const githubToken = process.env.GITHUB_TOKEN;

  if (!githubToken) {
    console.error('‚ùå GITHUB_TOKEN environment variable not configured');
    return false;
  }

  try {
    const comment = formatAgentFindingsForGitHub(responses);

    console.log(`\nüìù Updating PR comment #${commentId}...`);

    await axios.patch(
      `https://api.github.com/repos/${repoOwner}/${repoName}/issues/comments/${commentId}`,
      { body: comment },
      {
        headers: {
          Authorization: `token ${githubToken}`,
          'Content-Type': 'application/json',
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    console.log(`‚úÖ PR comment updated successfully`);
    return true;
  } catch (error: any) {
    console.error(`‚ùå Failed to update PR comment:`, error.message);
    return false;
  }
}

/**
 * Find existing agent findings comment on a PR
 */
export async function findAgentComment(
  context: GitHubPRContext
): Promise<number | null> {
  const { repoOwner, repoName, prNumber } = context;
  const githubToken = process.env.GITHUB_TOKEN;

  if (!githubToken) {
    return null;
  }

  try {
    const response = await axios.get(
      `https://api.github.com/repos/${repoOwner}/${repoName}/issues/${prNumber}/comments`,
      {
        headers: {
          Authorization: `token ${githubToken}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    // Look for existing agent findings comment
    const agentComment = response.data.find(
      (comment: any) =>
        comment.user.login === 'github-actions' ||
        comment.body.includes('Automated Agent Analysis')
    );

    return agentComment?.id || null;
  } catch (error: any) {
    console.warn('‚ö†Ô∏è Failed to fetch PR comments:', error.message);
    return null;
  }
}

/**
 * Post or update agent findings on PR (idempotent)
 */
export async function postOrUpdatePRFindings(
  context: GitHubPRContext,
  responses: AgentResponse[]
): Promise<boolean> {
  // Try to find existing comment
  const existingCommentId = await findAgentComment(context);

  if (existingCommentId) {
    // Update existing comment
    return updatePRComment(context, existingCommentId, responses);
  } else {
    // Create new comment
    return postPRComment(context, responses);
  }
}

/**
 * Helper: Get agent display icon
 */
function getAgentIcon(agentType: string): string {
  const icons: Record<string, string> = {
    'backend-engineer': 'üîß',
    'senior-frontend': 'üé®',
    'security-analyst': 'üîí',
    'design-review': '‚ú®',
    'qa-testing': '‚úÖ',
    'system-architecture': 'üèóÔ∏è',
    devops: 'üöÄ',
    'product-manager': 'üìä',
    'ui-ux': 'üñºÔ∏è',
  };
  return icons[agentType] || 'ü§ñ';
}

/**
 * Post agent findings to workflow run (if associated with PR)
 */
export async function postWorkflowFindings(
  context: GitHubPRContext,
  responses: AgentResponse[]
): Promise<boolean> {
  // Workflow findings use same PR comment format
  return postPRComment(context, responses);
}

/**
 * Helper: Get agent display name
 */
function getAgentName(agentType: string): string {
  const names: Record<string, string> = {
    'backend-engineer': 'Backend Engineer',
    'senior-frontend': 'Senior Frontend Engineer',
    'security-analyst': 'Security Analyst',
    'design-review': 'Design Review',
    'qa-testing': 'QA Testing',
    'system-architecture': 'System Architecture',
    devops: 'DevOps',
    'product-manager': 'Product Manager',
    'ui-ux': 'UI/UX Design',
  };
  return names[agentType] || agentType;
}
